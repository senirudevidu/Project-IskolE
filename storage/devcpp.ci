[INTER_|_Divided_Diff_Forward_Central_Backward]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_$_double v(double t) {$_    double numerator = 14.0e4;$_    double denominator = 14.0e4 - 2100.0 * t;$_    return 2000.0 * log(numerator / denominator) - 9.8 * t;$_}$_$_double a(double t, double dt) {$_    // Forward$_    // return (v(t + dt) - v(t)) / dt;$_$_    // Central$_    // return (v(t + dt) - v(t - dt)) / (2.0 * dt);$_$_    // Backward$_    return (v(t) - v(t - dt)) / dt;$_}$_$_int main() {$_    double t = 16.0;$_    double dt = 2.0;$_    double tol = 0.5;$_$_    double R[20]; // Result array$_    double dt_values[20];$_    int i = 0;$_    double error = 100.0;$_$_    // first estimate$_    R[0] = a(t, dt);$_    dt_values[0] = dt;$_    i = 1;$_$_    while (i < 20) {$_        dt = dt / 2.0;$_        R[i] = a(t, dt);$_        dt_values[i] = dt;$_$_        if (i > 0) {$_            error = fabs((R[i] - R[i - 1]) / R[i]) * 100.0;$_        }$_$_        i++;$_$_        if (error <= tol && i > 1) {$_            break;$_        }$_    }$_$_    printf("%-10s%-20s%-30s\n", "?t", "v'(t)", "|ea|%");$_    printf("---------------------------------------------------------------\n");$_    printf("%-10.3f%-20.6f%-30s\n", dt_values[0], R[0], "-");$_$_    for (int i = 1; i < i; i++) {$_        double current_error = fabs((R[i] - R[i - 1]) / R[i]) * 100.0;$_        printf("%-10.3f%-20.6f%-30.6f\n", dt_values[i], R[i], current_error);$_    }$_$_    printf("\n\nFinal estimate: %.6f m/s²\n", R[i - 1]);$_$_    return 0;$_}
Sep=5
[INTER_|_Liner_Interpolation]
Desc=
Line=#include <math.h>$_#include <stdio.h>$_$_#define MAX_POINTS 10$_$_typedef struct {$_    double a, b;$_    double x_start, x_end;$_} LinearSpline;$_$_int main() {$_    int n = 6;$_    double x[MAX_POINTS] = {0, 10, 15, 20, 22.5, 30};$_    double y[MAX_POINTS] = {0, 227.04, 362.78, 517.35, 602.97, 901.67};$_$_    LinearSpline S[MAX_POINTS];$_    int numSplines = n - 1;$_$_    // Calculate linear spline coefficients$_    for (int i = 0; i < numSplines; i++) {$_        double x1 = x[i], x2 = x[i + 1];$_        double y1 = y[i], y2 = y[i + 1];$_$_        S[i].x_start = x1;$_        S[i].x_end = x2;$_$_        S[i].a = (y2 - y1) / (x2 - x1);$_        S[i].b = y1 - S[i].a * x1;$_    }$_$_    // Print linear coefficients$_    printf("\nLinear Interpolation Coefficients:\n");$_    printf("%-5s%-20s%-20s\n", "i", "a_i", "b_i");$_    printf("------------------\n");$_    for (int i = 0; i < numSplines; i++) {$_        printf("%-5d%-20.6f%-20.6f\n", i + 1, S[i].a, S[i].b);$_    }$_    printf("\n");$_$_    // Evaluate spline at t=16$_    double velocity_16 = 0;$_    for (int i = 0; i < numSplines; i++) {$_        if (16.0 >= S[i].x_start && 16.0 <= S[i].x_end) {$_            velocity_16 = S[i].a * 16.0 + S[i].b;$_            break;$_        }$_    }$_    printf("Velocity at t=16s: %.2f m/s\n", velocity_16);$_$_    // Evaluate derivative at t=16$_    double acceleration_16 = 0;$_    for (int i = 0; i < numSplines; i++) {$_        if (16.0 >= S[i].x_start && 16.0 <= S[i].x_end) {$_            acceleration_16 = S[i].a;$_            break;$_        }$_    }$_    printf("Acceleration at t=16s: %.2f m/s²\n", acceleration_16);$_$_    // Integrate spline from t=11 to t=16$_    double totalDistance = 0.0;$_    for (int i = 0; i < numSplines; i++) {$_        double start = fmax(11.0, S[i].x_start);$_        double end = fmin(16.0, S[i].x_end);$_$_        if (start < end) {$_            double a = S[i].a;$_            double b = S[i].b;$_            double integral = (a / 2.0) * (end * end - start * start) + b * (end - start);$_
Sep=5
[INTER_|_Newton_Divided_Difference]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_$_#define MAX_POINTS 10$_$_// Function to calculate divided differences$_void dividedDifference(double x[], double y[], double table[][MAX_POINTS], int n) {$_    for (int i = 0; i < n; i++)$_        table[i][0] = y[i];$_$_    for (int j = 1; j < n; j++) {$_        for (int i = 0; i < n - j; i++) {$_            table[i][j] = (table[i + 1][j - 1] - table[i][j - 1]) / (x[i + j] - x[i]);$_        }$_    }$_}$_$_// Function to evaluate Newtonï¿½s polynomial up to a given order$_double newtonInterpolation(double x[], double table[][MAX_POINTS], double target, int order) {$_    double result = table[0][0];$_    double term = 1.0;$_    for (int i = 1; i <= order; i++) {$_        term *= (target - x[i - 1]);$_        result += term * table[0][i];$_    }$_    return result;$_}$_$_int main() {$_    // Hardcoded time and velocity data$_    int n = 5;$_    double x[MAX_POINTS] = {0, 10, 15, 20, 22.5};$_    double y[MAX_POINTS] = {0, 227.04, 362.78, 517.35, 602.97};$_    double table[MAX_POINTS][MAX_POINTS] = {0};$_    double target = 16.0;$_$_    // Calculate divided difference table$_    dividedDifference(x, y, table, n);$_$_    // Interpolate for orders 1 to 3$_    double results[4] = {0}; // index 0 unused$_    for (int order = 1; order <= 3; order++) {$_        results[order] = newtonInterpolation(x, table, target, order);$_    }$_$_    // Output table$_    printf("\n%-10s%-20s%-30s\n", "Order", "Velocity Estimate", "Abs Rel Approx Error (%)");$_    printf("---------------------------------------------------------------\n");$_    printf("%-10d%-20.8lf%-30s\n", 1, results[1], "-");$_    for (int i = 2; i <= 3; i++) {$_        double error = fabs((results[i] - results[i - 1]) / results[i]) * 100.0;$_        printf("%-10d%-20.8lf%-30.6lf\n", i, results[i], error);$_    }$_$_    return 0;$_}$_
Sep=5
[INTER_|_Spline_Main]
Desc=
Line=#include <math.h>$_#include <stdio.h>$_$_#define MAX_POINTS 10$_#define MAX_SPLINES 10$_$_$_typedef struct {$_    double a, b, c;$_    double x_start, x_end;$_} QuadraticSpline;$_$_void solveQuadraticSplines(double x[], double y[], int n, QuadraticSpline splines[]) {$_    int numSplines = n - 1;$_$_    for (int i = 0; i < numSplines; i++) {$_        double x1 = x[i], x2 = x[i + 1];$_        double y1 = y[i], y2 = y[i + 1];$_$_        splines[i].x_start = x1;$_        splines[i].x_end = x2;$_$_        if (i == 0) {$_$_            splines[i].a = 0;$_            splines[i].b = (y2 - y1) / (x2 - x1);$_            splines[i].c = y1 - splines[i].b * x1;$_        } else {$_$_            double h_prev = x[i] - x[i - 1];$_            double h_curr = x[i + 1] - x[i];$_            double dy_prev = y[i] - y[i - 1];$_            double dy_curr = y[i + 1] - y[i];$_$_            double d2y = 2.0 * ((dy_curr / h_curr) - (dy_prev / h_prev)) / (h_prev + h_curr);$_$_            splines[i].a = d2y / 2.0;$_            splines[i].b = (dy_curr / h_curr) - splines[i].a * (x1 + x2);$_            splines[i].c = y1 - splines[i].a * x1 * x1 - splines[i].b * x1;$_        }$_    }$_}$_$_void printSplineCoefficients(QuadraticSpline splines[], int numSplines, double x[]) {$_    printf("\nQuadratic Spline Coefficients:\n");$_    printf("%-5s%-20s%-20s%-20s\n", "i", "a_i", "b_i", "c_i");$_    printf("---------------------------------------------------------------\n");$_    for (int i = 0; i < numSplines; i++) {$_        printf("%-5d%-20.6f%-20.6f%-20.6f\n",$_               i+1, splines[i].a, splines[i].b, splines[i].c);$_    }$_    printf("\n");$_}$_$_int main() {$_    int n = 6;$_    double x[MAX_POINTS] = {0, 10, 15, 20, 22.5, 30};$_    double y[MAX_POINTS] = {0, 227.04, 362.78, 517.35, 602.97, 901.67};$_$_    QuadraticSpline splines[MAX_SPLINES];$_    int numSplines = n - 1;$_$_    solveQuadraticSplines(x, y, n, splines);$_$_    printSplineCoefficients(splines, numSplines, x);$_$_    return 0;$_}
Sep=5
[INTER_|_Lagrange]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_double lagrangian_basis(double x, int i, double *t_points, int n) {$_    double result = 1.0;$_    for (int j = 0; j < n; j++) {$_        if (i != j) {$_            result *= (x - t_points[j]) / (t_points[i] - t_points[j]);$_        }$_    }$_    return result;$_}$_$_double lagrangian_interpolation(double x, double *t_points, double *v_points, int n) {$_    double result = 0.0;$_    for (int i = 0; i < n; i++) {$_        result += v_points[i] * lagrangian_basis(x, i, t_points, n);$_    }$_    return result;$_}$_$_double calculate_acceleration_lagrangian(double target_t, double *t_points, double *v_points, int n) {$_    double h = 0.001;$_$_    double v_plus = lagrangian_interpolation(target_t + h, t_points, v_points, n);$_    double v_minus = lagrangian_interpolation(target_t - h, t_points, v_points, n);$_$_    return (v_plus - v_minus) / (2.0 * h);$_}$_$_int main() {$_    double target_t = 16.0;$_$_    double t_selected[] = {10, 15, 20};$_    double v_selected[] = {227.04, 362.78, 517.35};$_    int n_selected = 3;$_$_$_    double interpolated_velocity = lagrangian_interpolation(target_t, t_selected, v_selected, n_selected);$_    printf("Interpolated velocity at t = %.1f s: %.4f m/s\n", target_t, interpolated_velocity);$_$_    double acceleration = calculate_acceleration_lagrangian(target_t, t_selected, v_selected, n_selected);$_$_    printf("Acceleration at t = %.1f s: %.6f m/s²\n", target_t, acceleration);$_$_    return 0;$_}
Sep=5
[INTER_|_Spline_Calc]
Desc=
Line=$_double evaluateSpline(QuadraticSpline splines[], int numSplines, double target) {$_    for (int i = 0; i < numSplines; i++) {$_        if (target >= splines[i].x_start && target <= splines[i].x_end) {$_            double a = splines[i].a;$_            double b = splines[i].b;$_            double c = splines[i].c;$_            return a * target * target + b * target + c;$_        }$_    }$_    return 0;$_}$_$_double evaluateDerivative(QuadraticSpline splines[], int numSplines, double target) {$_    for (int i = 0; i < numSplines; i++) {$_        if (target >= splines[i].x_start && target <= splines[i].x_end) {$_            double a = splines[i].a;$_            double b = splines[i].b;$_            return 2 * a * target + b;$_        }$_    }$_    return 0;$_}$_$_double integrateSpline(QuadraticSpline splines[], int numSplines, double t1, double t2) {$_    double totalDistance = 0.0;$_$_    for (int i = 0; i < numSplines; i++) {$_        double start = fmax(t1, splines[i].x_start);$_        double end = fmin(t2, splines[i].x_end);$_$_        if (start < end) {$_            double a = splines[i].a;$_            double b = splines[i].b;$_            double c = splines[i].c;$_$_            double integral = (a / 3.0) * (end * end * end - start * start * start) +$_                              (b / 2.0) * (end * end - start * start) +$_                              c * (end - start);$_            totalDistance += integral;$_        }$_    }$_$_    return totalDistance;$_}$_$_    double velocity_16 = evaluateSpline(splines, numSplines, 16.0);$_    printf("Velocity at t=16s: %.2f m/s\n", velocity_16);$_$_    double acceleration_16 = evaluateDerivative(splines, numSplines, 16.0);$_    printf("Acceleration at t=16s: %.2f m/s²\n", acceleration_16);$_$_    double distance_11_16 = integrateSpline(splines, numSplines, 11.0, 16.0);$_    printf("Distance covered between t=11s and t=16s: %.2f m\n", distance_11_16);
Sep=5
[DECOM_|_LU]
Desc=
Line=#include <stdio.h>$_$_#define N 3$_$_void luDecomposition(float A[N][N], float L[N][N], float U[N][N]) {$_    for (int i = 0; i < N; i++) {$_        // Upper Triangular$_        for (int k = i; k < N; k++) {$_            float sum = 0;$_            for (int j = 0; j < i; j++)$_                sum += L[i][j] * U[j][k];$_            U[i][k] = A[i][k] - sum;$_        }$_$_        // Lower Triangular$_        for (int k = i; k < N; k++) {$_            if (i == k)$_                L[i][i] = 1;$_            else {$_                float sum = 0;$_                for (int j = 0; j < i; j++)$_                    sum += L[k][j] * U[j][i];$_                L[k][i] = (A[k][i] - sum) / U[i][i];$_            }$_        }$_    }$_}$_$_void forwardSubstitution(float L[N][N], float b[N], float y[N]) {$_    for (int i = 0; i < N; i++) {$_        y[i] = b[i];$_        for (int j = 0; j < i; j++)$_            y[i] -= L[i][j] * y[j];$_    }$_}$_$_void backwardSubstitution(float U[N][N], float y[N], float x[N]) {$_    for (int i = N - 1; i >= 0; i--) {$_        x[i] = y[i];$_        for (int j = i + 1; j < N; j++)$_            x[i] -= U[i][j] * x[j];$_        x[i] /= U[i][i];$_    }$_}$_$_void printVector(const char* name, float v[N]) {$_    printf("%s = [", name);$_    for (int i = 0; i < N; i++) {$_        printf(" %.4f", v[i]);$_    }$_    printf(" ]\n");$_}$_$_int main() {$_    float A[N][N] = {$_        {25, 5, 1},$_        {64, 8, 1},$_        {144, 12, 1}$_    };$_$_    float b[N] = {106.8, 177.2, 279.2};$_    float L[N][N] = {0}, U[N][N] = {0};$_    float y[N], x[N];$_$_    luDecomposition(A, L, U);$_    forwardSubstitution(L, b, y);$_    backwardSubstitution(U, y, x);$_$_    printf("Solution:\n");$_    printVector("x", x);$_$_    return 0;$_}$_
Sep=6
[DECOM_|_Cholesky]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_$_#define N 3$_$_void choleskyDecomposition(float A[N][N], float L[N][N]) {$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j <= i; j++) {$_            float sum = 0;$_$_            if (j == i) { // Diagonal elements$_                for (int k = 0; k < j; k++)$_                    sum += L[j][k] * L[j][k];$_                L[j][j] = sqrt(A[j][j] - sum);$_            } else {$_                for (int k = 0; k < j; k++)$_                    sum += L[i][k] * L[j][k];$_                L[i][j] = (A[i][j] - sum) / L[j][j];$_            }$_        }$_    }$_}$_$_// Display a matrix$_void printMatrix(float M[N][N]) {$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++)$_            printf("%8.4f ", M[i][j]);$_        printf("\n");$_    }$_}$_$_// Forward substitution to solve Ly = b$_void forwardSubstitution(float L[N][N], float b[N], float y[N]) {$_    for (int i = 0; i < N; i++) {$_        float sum = 0;$_        for (int j = 0; j < i; j++)$_            sum += L[i][j] * y[j];$_        y[i] = (b[i] - sum) / L[i][i];$_    }$_}$_$_// Backward substitution to solve L^T x = y$_void backwardSubstitution(float L[N][N], float y[N], float x[N]) {$_    for (int i = N - 1; i >= 0; i--) {$_        float sum = 0;$_        for (int j = i + 1; j < N; j++)$_            sum += L[j][i] * x[j];$_        x[i] = (y[i] - sum) / L[i][i];$_    }$_}$_$_int main() {$_    float A[N][N] = {$_        {4, 12, -16},$_        {12, 37, -43},$_        {-16, -43, 98}$_    };$_$_    float b[N] = {1, 2, 3}; // Example right-hand side vector$_    float L[N][N] = {0};$_    float y[N] = {0};$_    float x[N] = {0};$_$_    printf("System of equations (Ax = b):\n");$_    for (int i = 0; i < N; i++) {$_        printf("%8.4f*x1 ", A[i][0]);$_        for (int j = 1; j < N; j++) {$_            if (A[i][j] >= 0)$_                printf("+ %8.4f*x%d ", A[i][j], j+1);$_            else$_                printf("- %8.4f*x%d ", -A[i][j], j+1);$_        }$_        printf("= %8.4f\n", b[i]);$_    }$_$
Sep=6
[DECOM_|_Gaussian]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_$_#define N 3$_$_void gaussianElimination(float A[N][N+1], float x[N]) {$_    // Forward Elimination$_    for (int i = 0; i < N - 1; i++) {$_        // Partial Pivoting (optional for numerical stability)$_        for (int k = i + 1; k < N; k++) {$_            if (fabs(A[k][i]) > fabs(A[i][i])) {$_                for (int j = 0; j <= N; j++) {$_                    float temp = A[i][j];$_                    A[i][j] = A[k][j];$_                    A[k][j] = temp;$_                }$_            }$_        }$_$_        // Eliminate below pivot$_        for (int k = i + 1; k < N; k++) {$_            float factor = A[k][i] / A[i][i];$_            for (int j = i; j <= N; j++) {$_                A[k][j] -= factor * A[i][j];$_            }$_        }$_    }$_$_    // Back Substitution$_    for (int i = N - 1; i >= 0; i--) {$_        x[i] = A[i][N];$_        for (int j = i + 1; j < N; j++) {$_            x[i] -= A[i][j] * x[j];$_        }$_        x[i] /= A[i][i];$_    }$_}$_$_void printVector(const char* name, float v[N]) {$_    printf("%s = [", name);$_    for (int i = 0; i < N; i++) {$_        printf(" %.4f", v[i]);$_    }$_    printf(" ]\n");$_}$_$_int main() {$_    // Augmented matrix A|b$_    float A[N][N+1] = {$_        {25, 5, 1, 106.8},$_        {64, 8, 1, 177.2},$_        {144, 12, 1, 279.2}$_    };$_$_    float x[N];$_$_    printf("Solving system using Gaussian Elimination...\n");$_    gaussianElimination(A, x);$_$_    printf("Solution:\n");$_    printVector("x", x);$_$_    return 0;$_}$_
Sep=6
[DECOM_|_LU_Inverse]
Desc=
Line=#include <stdio.h>$_$_#define N 3$_$_void luDecomposition(float A[N][N], float L[N][N], float U[N][N]) {$_    for (int i = 0; i < N; i++) {$_        for (int k = i; k < N; k++) {$_            float sum = 0;$_            for (int j = 0; j < i; j++)$_                sum += L[i][j] * U[j][k];$_            U[i][k] = A[i][k] - sum;$_        }$_$_        for (int k = i; k < N; k++) {$_            if (i == k)$_                L[i][i] = 1;$_            else {$_                float sum = 0;$_                for (int j = 0; j < i; j++)$_                    sum += L[k][j] * U[j][i];$_                L[k][i] = (A[k][i] - sum) / U[i][i];$_            }$_        }$_    }$_}$_$_void forwardSubstitution(float L[N][N], float b[N], float y[N]) {$_    for (int i = 0; i < N; i++) {$_        y[i] = b[i];$_        for (int j = 0; j < i; j++)$_            y[i] -= L[i][j] * y[j];$_    }$_}$_$_void backwardSubstitution(float U[N][N], float y[N], float x[N]) {$_    for (int i = N - 1; i >= 0; i--) {$_        x[i] = y[i];$_        for (int j = i + 1; j < N; j++)$_            x[i] -= U[i][j] * x[j];$_        x[i] /= U[i][i];$_    }$_}$_$_void inverseMatrix(float A[N][N], float A_inv[N][N]) {$_    float L[N][N] = {0}, U[N][N] = {0};$_    float e[N], y[N], x[N];$_$_    luDecomposition(A, L, U);$_$_    for (int col = 0; col < N; col++) {$_        // Create the identity matrix column e_i$_        for (int i = 0; i < N; i++)$_            e[i] = (i == col) ? 1 : 0;$_$_        forwardSubstitution(L, e, y);$_        backwardSubstitution(U, y, x);$_$_        // Store the result as a column in A_inv$_        for (int i = 0; i < N; i++)$_            A_inv[i][col] = x[i];$_    }$_}$_$_void printMatrix(float M[N][N]) {$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++)$_            printf("%8.4f ", M[i][j]);$_        printf("\n");$_    }$_}$_$_int main() {$_    float A[N][N] = {$_        {25, 5, 1},$_        {64, 8, 1},$_        {144, 12, 1}$_    };$_$_    float A_inv[N][N];$_$_    inverseMatrix(A, A_inv);$_$_    printf("Inverse o
Sep=6
[MATRIX_|_Householder_&_Jacobi]
Desc=
Line=#include <math.h>$_#include <stdbool.h>$_#include <stdio.h>$_$_#define N 4$_#define EPSILON 1e-4$_$_double A[N][N] = {$_    {4, 1, -2, 2},$_    {1, 2, 0, 1},$_    {-2, 0, 3, -2},$_    {2, 1, -2, -1}};$_const double I[N][N] = {$_    {1, 0, 0, 0},$_    {0, 1, 0, 0},$_    {0, 0, 1, 0},$_    {0, 0, 0, 1}};$_$_double V[N][N] = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};$_double J[N][N] = {0};$_double t, c, s;$_int p, q;$_$_void printMatrix(char* txt, double matrix[N][N]) {$_    printf("\t%s\n", txt);$_    for (int i = 0; i < N; i++) {$_        printf("\t");$_        for (int j = 0; j < N; j++) {$_            printf("%8.4f ", matrix[i][j]);$_        }$_        printf("\n");$_    }$_}$_$_void print_eigenvalues_and_vectors() {$_    printf("\nEigenvalues:\n");$_    for (int i = 0; i < N; i++) {$_        printf("L%d = %.6f\n", i + 1, A[i][i]);$_    }$_$_    printf("\nEigenvectors (columns of V):\n");$_    for (int i = 0; i < N; i++) {$_        printf("v%d = [", i + 1);$_        for (int j = 0; j < N; j++) {$_            printf(" %.6f", V[j][i]);$_            if (j < N - 1) printf(",");$_        }$_        printf(" ]\n");$_    }$_}$_$_$_$_int main() {$_    printf("Original Matrix:\n");$_    printMatrix("A", A);$_$_    householder_tridiagonalize();$_    printf("\nTridiagonalized Matrix (Householder):\n");$_    printMatrix("A", A);$_$_    // Reset V to identity for Jacobi$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            V[i][j] = (i == j) ? 1 : 0;$_        }$_    }$_    while (!converged()) {$_        find_pivot();$_        compute_angles();$_        jacobi_rotation();$_        compute_J_and_V();$_    }$_    printf("\nDiagonalized Matrix (Jacobi):\n");$_    printMatrix("A", A);$_    printMatrix("V", V);$_    print_eigenvalues_and_vectors();$_    return 0;$_}
Sep=7
[MATRIX_|_Householder]
Desc=
Line=#include <math.h>$_#include <stdbool.h>$_#include <stdio.h>$_#define N 4$_$_double$_    A[N][N] = {$_        {4, 1, -2, 2},$_        {1, 2, 0, 1},$_        {-2, 0, 3, -2},$_        {2, 1, -2, -1}};$_const double$_    I[N][N] = {$_        {1, 0, 0, 0},$_        {0, 1, 0, 0},$_        {0, 0, 1, 0},$_        {0, 0, 0, 1}};$_$_void printMatrix(double matrix[N][N]) {$_    printf("\n");$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            printf("%8.4f ", matrix[i][j]);$_        }$_        printf("\n");$_    }$_}$_$_int main() {$_    for (int i = 0; i < N - 2; i++) {$_        // Step 1: Get X[] and fill values$_        double X[N] = {0};$_        for (int j = i + 1; j < N; j++) {$_            X[j] = A[j][i];$_        }$_$_        // Step 2: V = X + (alpha).e$_        // alpha = sign(x[i+1]) * norm_x$_        double$_            norm_x = 0,$_            e[N] = {0};$_        e[i + 1] = 1;$_        for (int j = 0; j < N; j++) {$_            norm_x += pow(X[j], 2);$_        }$_        norm_x = sqrt(norm_x);$_        double alpha = copysign(norm_x, X[i + 1]);$_        double V[N] = {0};$_        for (int j = 0; j < N; j++) {$_            V[j] = X[j] + alpha * e[j];$_        }$_$_        // Step 3: Computer U = V/||V||$_        double norm_v = 0;$_        for (int j = 0; j < N; j++) {$_            norm_v += pow(V[j], 2);$_        }$_        norm_v = sqrt(norm_v);$_        double U[N] = {0};$_        for (int j = 0; j < N; j++) {$_            U[j] = V[j] / norm_v;$_        }$_$_        // Step 4: Compute H = [I] - 2*[U][UT]$_        double UUT[N][N] = {0};$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                UUT[j][k] += U[j] * U[k];$_            }$_        }$_$_        double H[N][N];$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                H[j][k] = I[j][k] - 2 * UUT[j][k];$_            }$_        }$_$_        // Step 5: A = HAH$_        /**$_         * B = HA$_         * A' = BH$_         */$_        d
Sep=7
[MATRIX_|_Jacobi]
Desc=
Line=#include <math.h>$_#include <stdbool.h>$_#include <stdio.h>$_$_#define N 4$_#define EPSILON 1e-4$_$_double$_    A[N][N] = {$_        {4, 1, -2, 2},$_        {1, 2, 0, 1},$_        {-2, 0, 3, -2},$_        {2, 1, -2, -1}};$_$_double V[N][N] = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};$_double J[N][N] = {0};$_$_double t, c, s;$_$_int p,$_    q;$_$_void printMatrix(char* txt, double matrix[N][N]) {$_    printf("\t%s\n", txt);$_    for (int i = 0; i < N; i++) {$_        printf("\t");$_        for (int j = 0; j < N; j++) {$_            printf("%8.4f ", matrix[i][j]);$_        }$_        printf("\n");$_    }$_}$_$_void print_eigenvalues_and_vectors() {$_    printf("\nEigenvalues:\n");$_    for (int i = 0; i < N; i++) {$_        printf("L%d = %.6f\n", i + 1, A[i][i]);$_    }$_$_    printf("\nEigenvectors (columns of V):\n");$_    for (int i = 0; i < N; i++) {$_        printf("v%d = [", i + 1);$_        for (int j = 0; j < N; j++) {$_            printf(" %.6f", V[j][i]);$_            if (j < N - 1) printf(",");$_        }$_        printf(" ]\n");$_    }$_}$_$_void compute_J_and_V() {$_    double temp[N][N] = {0};$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            (i == j) ? (J[i][j] = 1) : (J[i][j] = 0);$_            temp[i][j] = V[i][j];$_        }$_    }$_$_    J[p][p] = J[q][q] = c;$_    J[p][q] = s;$_    J[q][p] = -s;$_$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            double sum = 0.0;$_            for (int k = 0; k < N; k++) {$_                sum += temp[i][k] * J[k][j];$_            }$_            V[i][j] = sum;$_        }$_    }$_}$_$_int main() {$_    while (!converged()) {$_        find_pivot();$_        compute_angles();$_        jacobi_rotation();$_        compute_J_and_V();$_    }$_    printMatrix("A", A);$_    printMatrix("V", V);$_$_    print_eigenvalues_and_vectors();$_}
Sep=7
[MATRIX_|_Jacobi_missing_methods)]
Desc=
Line=bool converged() {$_    double total = 0.0;$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < i; j++) {$_            total += pow(A[i][j], 2) * 2;$_        }$_    }$_    return sqrt(total) < EPSILON;$_}$_$_void find_pivot() {$_    double max = 0.0;$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < i; j++) {$_            if (fabs(A[i][j]) > max) {$_                max = fabs(A[i][j]);$_                p = i;$_                q = j;$_            }$_        }$_    }$_}$_$_void compute_angles() {$_    double tau = (A[q][q] - A[p][p]) / (2 * A[p][q]);$_    if (tau >= 0.0) {$_        t = 1.0 / (fabs(tau) + sqrt(1 + pow(tau, 2)));$_    } else {$_        t = -1.0 / (fabs(tau) + sqrt(1 + pow(tau, 2)));$_    }$_$_    c = 1.0 / sqrt(1 + pow(t, 2));$_    s = c * t;$_}$_$_void jacobi_rotation() {$_    double$_        A_dash_pp,$_        A_dash_qq,$_        A_dash_pq,$_        c_2 = pow(c, 2),$_        s_2 = pow(s, 2),$_        sc2 = c * s * 2;$_$_    A_dash_pp = c_2 * A[p][p] - sc2 * A[p][q] + s_2 * A[q][q];$_    A_dash_qq = s_2 * A[p][p] + sc2 * A[p][q] + c_2 * A[q][q];$_    A_dash_pq = 0.0;$_$_    A[p][p] = A_dash_pp;$_    A[q][q] = A_dash_qq;$_    A[p][q] = A[q][p] = A_dash_pq;$_$_    double$_        A_dash_ip,$_        A_dash_iq;$_    for (int i = 0; i < N; i++) {$_        if (i != p && i != q) {$_            A_dash_ip = c * A[i][p] - s * A[i][q];$_            A_dash_iq = s * A[i][p] + c * A[i][q];$_            A[i][p] = A[p][i] = A_dash_ip;$_            A[i][q] = A[q][i] = A_dash_iq;$_        }$_    }$_}
Sep=7
[MATRIX_|_Householder_&_Jacobi_(Missing_Methods)]
Desc=
Line=bool converged() {$_    double total = 0.0;$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < i; j++) {$_            total += pow(A[i][j], 2) * 2;$_        }$_    }$_    return sqrt(total) < EPSILON;$_}$_$_void find_pivot() {$_    double max = 0.0;$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < i; j++) {$_            if (fabs(A[i][j]) > max) {$_                max = fabs(A[i][j]);$_                p = i;$_                q = j;$_            }$_        }$_    }$_}$_$_void compute_angles() {$_    double tau = (A[q][q] - A[p][p]) / (2 * A[p][q]);$_    if (tau >= 0.0) {$_        t = 1.0 / (fabs(tau) + sqrt(1 + pow(tau, 2)));$_    } else {$_        t = -1.0 / (fabs(tau) + sqrt(1 + pow(tau, 2)));$_    }$_$_    c = 1.0 / sqrt(1 + pow(t, 2));$_    s = c * t;$_}$_$_void jacobi_rotation() {$_    double A_dash_pp, A_dash_qq, A_dash_pq, c_2 = pow(c, 2), s_2 = pow(s, 2), sc2 = c * s * 2;$_$_    A_dash_pp = c_2 * A[p][p] - sc2 * A[p][q] + s_2 * A[q][q];$_    A_dash_qq = s_2 * A[p][p] + sc2 * A[p][q] + c_2 * A[q][q];$_    A_dash_pq = 0.0;$_$_    A[p][p] = A_dash_pp;$_    A[q][q] = A_dash_qq;$_    A[p][q] = A[q][p] = A_dash_pq;$_$_    double A_dash_ip, A_dash_iq;$_    for (int i = 0; i < N; i++) {$_        if (i != p && i != q) {$_            A_dash_ip = c * A[i][p] - s * A[i][q];$_            A_dash_iq = s * A[i][p] + c * A[i][q];$_            A[i][p] = A[p][i] = A_dash_ip;$_            A[i][q] = A[q][i] = A_dash_iq;$_        }$_    }$_}$_$_void compute_J_and_V() {$_    double temp[N][N] = {0};$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            (i == j) ? (J[i][j] = 1) : (J[i][j] = 0);$_            temp[i][j] = V[i][j];$_        }$_    }$_    J[p][p] = J[q][q] = c;$_    J[p][q] = s;$_    J[q][p] = -s;$_$_    for (int i = 0; i < N; i++) {$_        for (int j = 0; j < N; j++) {$_            double sum = 0.0;$_            for (int k = 0; k < N; k++) {$_                sum += temp[i][k] * J[k][j];$_            }$_            V[i][j] = sum;$_        }$_    }$_}
Sep=7
[MATRIX_|_Householder_&_Jacobi_(Missing_Methods_2)]
Desc=
Line=void householder_tridiagonalize() {$_    for (int i = 0; i < N - 2; i++) {$_        double X[N] = {0};$_        for (int j = i + 1; j < N; j++) {$_            X[j] = A[j][i];$_        }$_        double norm_x = 0, e[N] = {0};$_        e[i + 1] = 1;$_        for (int j = 0; j < N; j++) {$_            norm_x += pow(X[j], 2);$_        }$_        norm_x = sqrt(norm_x);$_        double alpha = copysign(norm_x, X[i + 1]);$_        double Vv[N] = {0};$_        for (int j = 0; j < N; j++) {$_            Vv[j] = X[j] + alpha * e[j];$_        }$_        double norm_v = 0;$_        for (int j = 0; j < N; j++) {$_            norm_v += pow(Vv[j], 2);$_        }$_        norm_v = sqrt(norm_v);$_        double U[N] = {0};$_        for (int j = 0; j < N; j++) {$_            U[j] = Vv[j] / norm_v;$_        }$_        double UUT[N][N] = {0};$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                UUT[j][k] += U[j] * U[k];$_            }$_        }$_        double H[N][N];$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                H[j][k] = I[j][k] - 2 * UUT[j][k];$_            }$_        }$_        double B[N][N] = {0};$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                double sum = 0.0;$_                for (int l = 0; l < N; l++) {$_                    sum += H[j][l] * A[l][k];$_                }$_                B[j][k] = sum;$_            }$_        }$_        for (int j = 0; j < N; j++) {$_            for (int k = 0; k < N; k++) {$_                double sum = 0.0;$_                for (int l = 0; l < N; l++) {$_                    sum += B[j][l] * H[l][k];$_                }$_                A[j][k] = sum;$_            }$_        }$_    }$_}
Sep=7
[ROOT_|_Bisection]
Desc=
Line=#include <math.h>$_#include <stdio.h>$_$_#define EPSILON pow(10, -4)$_#define MAX_ITER 1000$_$_double f(double x) {$_    // equation: x^3 - 0.165*x^2 + 3.993e-4 = 0$_    return pow(x, 3) - 0.165 * pow(x, 2) + 3.993e-4;$_}$_$_int digits(double error) {$_    return (int)(2 - log10(2 * error / 100));$_}$_$_void bisection_method() {$_    double R = 0.055;$_    double x_a = 0.0;$_    double x_b = 2 * R;$_    double x_m, x_prev = 0.0, error = 0.0;$_$_    if (f(x_a) * f(x_b) > 0) {$_        printf("Change boundary\n");$_        return;$_    }$_$_    printf("Iter |    a     |    b     |    xm    |  f(xm)   | Abs. Error (%%) | Sig. Digits\n");$_    for (int i = 1; i <= 3; i++) {$_        x_m = (x_a + x_b) / 2.0;$_        double f_a = f(x_a);$_        double f_m = f(x_m);$_        double f_b = f(x_b);$_        if (f_a * f_m < 0) {$_            x_b = x_m;$_        } else {$_            x_a = x_m;$_        }$_        if (i == 1) {$_            printf("%3d  | %8.5lf | %8.5lf | %8.5lf | %8.5lf |     ------     |    -----\n", i, x_a, x_b, x_m, f_m);$_        } else {$_            error = fabs((x_m - x_prev) / x_m) * 100.0;$_            printf("%3d  | %8.5lf | %8.5lf | %8.5lf | %8.5lf | %13.6lf | %9d\n", i, x_a, x_b, x_m, f_m, error, digits(error));$_        }$_        x_prev = x_m;$_    }$_    printf("\nEstimated submerged depth after 3 iterations: x = %.6lf cm\n", x_m);$_}$_$_int main() {$_    bisection_method();$_    return 0;$_}$_
Sep=8
[ROOT_|_Newton_Raphson]
Desc=
Line=#include <math.h>$_#include <stdio.h>$_$_#define MAX_ITER 1000$_#define EPSILON pow(10, -4)$_$_double f(double x) {$_    // equation: x^3 - 0.165*x^2 + 3.993e-4 = 0$_    return pow(x, 3) - 0.165 * pow(x, 2) + 3.993e-4;$_}$_double df(double x) {$_    // derivative: 3x^2 - 0.33x$_    return 3 * pow(x, 2) - 0.33 * x;$_}$_$_int digits(double e) {$_    return (int)(2 - log10(2 * e / 100));$_}$_$_void newton_raphson_method() {$_    double R = 0.055;$_    double x_prev = R;  // start at midpoint$_    double error = 1, x_0;$_$_    printf("Iter |   x_prev |   x_0    |  f(x_0)   | Abs. Error (%%) | Sig. Digits\n");$_    for (int i = 1; i <= 3; i++) {$_        x_0 = x_prev - f(x_prev) / df(x_prev);$_        double f_0 = f(x_0);$_        if (i == 1) {$_            printf("%3d  | %8.5lf | %8.5lf | %10.5lf |     ------     |    -----\n", i, x_prev, x_0, f_0);$_        } else {$_            error = fabs((x_0 - x_prev) / x_0) * 100;$_            printf("%3d  | %8.5lf | %8.5lf | %10.5lf | %13.6lf | %9d\n", i, x_prev, x_0, f_0, error, digits(error));$_        }$_        x_prev = x_0;$_    }$_    printf("\nEstimated submerged depth after 3 iterations: x = %.6lf cm\n", x_0);$_}$_$_int main() {$_    newton_raphson_method();$_    return 0;$_}$_
Sep=8
[ROOT_|_Secant]
Desc=
Line=#include <math.h>$_#include <stdio.h>$_$_#define MAX_ITER 1000$_#define TOLERANCE 1e-7$_$_double f(double x) {$_    // equation: x^3 - 0.165*x^2 + 3.993e-4 = 0$_    return pow(x, 3) - 0.165 * pow(x, 2) + 3.993e-4;$_}$_$_int digits(double e) {$_    return (int)(2 - log10(2 * e / 100));$_}$_$_void secant_method() {$_    double R = 0.055;$_    double x_prev = 0.01;             // close to lower bound$_    double x_current = 2 * R - 0.01;  // close to upper bound$_    double x_next, error = 1;$_$_    printf("Iter |   x_prev | x_current |   x_next  |  f(x_next) | Abs. Error (%%) | Sig. Digits\n");$_    for (int i = 1; i <= 3; i++) {$_        x_next = x_current - f(x_current) * ((x_current - x_prev) / (f(x_current) - f(x_prev)));$_        double f_next = f(x_next);$_        if (i == 1) {$_            printf("%3d  | %8.5lf | %8.5lf | %8.5lf | %10.5lf |     ------     |    -----\n", i, x_prev, x_current, x_next, f_next);$_        } else {$_            error = fabs((x_next - x_current) / x_next) * 100;$_            printf("%3d  | %8.5lf | %8.5lf | %8.5lf | %10.5lf | %13.6lf | %9d\n", i, x_prev, x_current, x_next, f_next, error, digits(error));$_        }$_        x_prev = x_current;$_        x_current = x_next;$_    }$_    printf("\nEstimated submerged depth after 3 iterations: x = %.6lf cm\n", x_next);$_}$_$_int main() {$_    secant_method();$_    return 0;$_}$_
Sep=8
[AREA_|_Trapezoid]
Desc=
Line=#include <stdio.h>$_#include <math.h>$_$_double velocity(double t) {$_    double numerator = 140000.0;$_    double denominator = 140000.0 - 2100.0 * t;$_    return 2000.0 * log(numerator / denominator) - 9.8 * t;$_}$_$_int main() {$_    double a = 8.0;$_    double b = 30.0;$_    double tolerance = 0.5;$_$_    double exact_value = analytical_integral(a, b);$_$_    printf("%-10s%-20s%-20s%-20s%-20s\n", "n", "Value", "Et", "|et|%", "|ea|%");$_    printf("-------------\n");$_$_    double prev = 0.0;$_    double Ea = 100.0;$_    int n = 1;$_$_    while (Ea > tolerance || n == 1) {$_        double i = trapezoidal_rule(a, b, n);$_        double true_error = exact_value - i;$_        double Et = fabs(true_error / exact_value) * 100.0;$_$_        if (n > 1) {$_            Ea = fabs((i - prev) / i) * 100.0;$_        }$_$_        printf("%-10d%-20.0f%-20.1f%-20.4f%-20.4f\n", n, i, true_error, Et, Ea);$_$_        prev = i;$_        n++;$_    }$_$_    printf("\n\nFinal estimate: %.1f\n", prev);$_$_    return 0;$_}
Sep=9
[AREA_|_Trapezoid_(Missing_methods)]
Desc=
Line=double analytical_integral(double a, double b) {$_    double result_b = 2000.0 * ((140000.0 - 2100.0 * b) / 2100.0) * log((140000.0 - 2100.0 * b) / 140000.0) + 2000.0 * b - 4.9 * b * b;$_    double result_a = 2000.0 * ((140000.0 - 2100.0 * a) / 2100.0) * log((140000.0 - 2100.0 * a) / 140000.0) + 2000.0 * a - 4.9 * a * a;$_$_    return result_b - result_a;$_}$_$_double trapezoidal_rule(double a, double b, int n) {$_    double h = (b - a) / n;$_    double sum = velocity(a) + velocity(b);$_$_    for (int i = 1; i < n; i++) {$_        double xi = a + i * h;$_        sum += 2.0 * velocity(xi);$_    }$_$_    return (h / 2.0) * sum;$_}
Sep=9
